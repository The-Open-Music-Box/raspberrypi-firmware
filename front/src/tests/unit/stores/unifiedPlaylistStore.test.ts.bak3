/**
 * Unit tests for unifiedPlaylistStore.ts
 *
 * Tests the centralized playlist and track data management store including:
 * - Playlist data loading and management
 * - Track data management by playlist
 * - WebSocket integration
 * - API integration
 * - Performance optimizations
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'
import { useUnifiedPlaylistStore } from '@/stores/unifiedPlaylistStore'

// Mock socketService
vi.mock('@/services/socketService', () => ({
  default: {
    on: vi.fn(),
    off: vi.fn(),
    emit: vi.fn(),
    isConnected: vi.fn(() => true),
    connect: vi.fn(),
    disconnect: vi.fn()
  }
}))

// Mock apiService
vi.mock('@/services/apiService', () => ({
  default: {
    getPlaylists: vi.fn(),
    getPlaylist: vi.fn(),
    getPlaylistTracks: vi.fn(),
    createPlaylist: vi.fn(),
    updatePlaylist: vi.fn(),
    deletePlaylist: vi.fn(),
    deleteTrack: vi.fn(),
    reorderTracks: vi.fn(),
    moveTrackBetweenPlaylists: vi.fn()
  }
}))

// Mock logger
vi.mock('@/utils/logger', () => ({
  logger: {
    info: vi.fn(),
    error: vi.fn(),
    debug: vi.fn(),
    warn: vi.fn()
  }
}))

// Mock constants
vi.mock('@/constants/apiRoutes', () => ({
  SOCKET_EVENTS: {
    PLAYLIST_UPDATED: 'playlist_updated',
    TRACK_UPDATED: 'track_updated'
  }
}))

// Mock track utils
vi.mock('@/utils/trackFieldAccessor', () => ({
  filterTrackByNumber: vi.fn((tracks, number) => tracks.find(t => t.number === number)),
  filterTracksByNumbers: vi.fn((tracks, numbers) => tracks.filter(t => numbers.includes(t.number))),
  validateTracksForDrag: vi.fn(() => ({ isValid: true })),
  createTrackIndexMap: vi.fn(() => new Map()),
  findTrackByNumberSafe: vi.fn((tracks, number) => tracks.find(t => t.number === number))
}))

// Mock drag error handler
vi.mock('@/utils/dragOperationErrorHandler', () => ({
  handleDragError: vi.fn(),
  DragContext: class {}
})))

describe('unifiedPlaylistStore', () => {
  let store: ReturnType<typeof useUnifiedPlaylistStore>
  let pinia: ReturnType<typeof createPinia>
  let mockApiService: any

  beforeEach(async () => {
    pinia = createPinia()
    setActivePinia(pinia)

    // Get the mocked API service
    mockApiService = (await import('@/services/apiService')).default

    store = useUnifiedPlaylistStore()
    vi.clearAllMocks()
  })

  afterEach(() => {
    vi.clearAllMocks()
  })

  describe('Store Initialization', () => {
    it('should initialize with default state', () => {
      expect(store.isLoading).toBe(false)
      expect(store.error).toBe(null)
      expect(store.lastSync).toBe(0)
      expect(store.isInitialized).toBe(false)
      expect(store.getAllPlaylists).toEqual([])
    })

    it('should have proper reactive state', () => {
      expect(typeof store.isLoading).toBe('boolean')
      expect(Array.isArray(store.getAllPlaylists)).toBe(true)
      expect(typeof store.getPlaylistById).toBe('function')
      expect(typeof store.getTracksForPlaylist).toBe('function')
    })
  })

  describe('Playlist Management', () => {
    it('should initialize the store', async () => {
      const mockPlaylists = [
        { id: 'pl1', title: 'Playlist 1', description: 'First playlist', track_count: 0 },
        { id: 'pl2', title: 'Playlist 2', description: 'Second playlist', track_count: 0 }
      ]

      mockApiService.getPlaylists.mockResolvedValue(mockPlaylists)

      await store.initialize()

      expect(mockApiService.getPlaylists).toHaveBeenCalled()
      expect(store.isInitialized).toBe(true)
      expect(store.getAllPlaylists).toHaveLength(2)
    })

    it('should load all playlists', async () => {
      const mockPlaylists = [
        { id: 'pl1', title: 'Playlist 1', description: 'First playlist', track_count: 0 },
        { id: 'pl2', title: 'Playlist 2', description: 'Second playlist', track_count: 0 }
      ]

      mockApiService.getPlaylists.mockResolvedValue(mockPlaylists)

      await store.loadAllPlaylists()

      expect(mockApiService.getPlaylists).toHaveBeenCalled()
      expect(store.getAllPlaylists).toHaveLength(2)
      expect(store.getPlaylistById('pl1')?.title).toBe('Playlist 1')
    })

    it('should handle playlist loading errors', async () => {
      const error = new Error('Failed to load playlists')
      mockApiService.getPlaylists.mockRejectedValue(error)

      await store.loadAllPlaylists()

      expect(store.error).toBe('Failed to load playlists')
      expect(store.isLoading).toBe(false)
    })

    it('should get playlist by ID', async () => {
      const mockPlaylists = [
        { id: 'pl1', title: 'Playlist 1', description: 'First playlist', track_count: 0 }
      ]

      mockApiService.getPlaylists.mockResolvedValue(mockPlaylists)
      await store.loadAllPlaylists()

      const playlist = store.getPlaylistById('pl1')
      expect(playlist?.title).toBe('Playlist 1')

      const nonExistent = store.getPlaylistById('nonexistent')
      expect(nonExistent).toBeUndefined()
    })

    it('should create new playlist', async () => {
      const newPlaylist = { id: 'new', title: 'New Playlist', description: 'Test playlist', track_count: 0 }
      mockApiService.createPlaylist.mockResolvedValue(newPlaylist)

      await store.createPlaylist('New Playlist', 'Test playlist')

      expect(mockApiService.createPlaylist).toHaveBeenCalledWith('New Playlist', 'Test playlist')
    })

    it('should update existing playlist', async () => {
      // First add a playlist
      const mockPlaylists = [
        { id: 'pl1', title: 'Playlist 1', description: 'First playlist', track_count: 0 }
      ]
      mockApiService.getPlaylists.mockResolvedValue(mockPlaylists)
      await store.loadAllPlaylists()

      const updatedPlaylist = { id: 'pl1', title: 'Updated Title', description: 'Updated description', track_count: 0 }
      mockApiService.updatePlaylist.mockResolvedValue(updatedPlaylist)

      await store.updatePlaylist('pl1', { title: 'Updated Title', description: 'Updated description' })

      expect(mockApiService.updatePlaylist).toHaveBeenCalledWith('pl1', expect.any(Object))
    })

    it('should delete playlist', async () => {
      // First add a playlist
      const mockPlaylists = [
        { id: 'pl1', title: 'Playlist 1', description: 'First playlist', track_count: 0 }
      ]
      mockApiService.getPlaylists.mockResolvedValue(mockPlaylists)
      await store.loadAllPlaylists()

      mockApiService.deletePlaylist.mockResolvedValue({ success: true })

      await store.deletePlaylist('pl1')

      expect(mockApiService.deletePlaylist).toHaveBeenCalledWith('pl1')
    })
  })

  describe('Track Management', () => {
    beforeEach(async () => {
      // Setup a playlist first
      const mockPlaylists = [
        { id: 'pl1', title: 'Playlist 1', description: 'First playlist', track_count: 2 }
      ]
      mockApiService.getPlaylists.mockResolvedValue(mockPlaylists)
      await store.loadAllPlaylists()
    })

    it('should load tracks for playlist', async () => {
      const mockPlaylistWithTracks = {
        id: 'pl1',
        title: 'Playlist 1',
        description: 'First playlist',
        track_count: 2,
        tracks: [
          { id: 't1', number: 1, title: 'Track 1', filename: 'track1.mp3' },
          { id: 't2', number: 2, title: 'Track 2', filename: 'track2.mp3' }
        ]
      }

      mockApiService.getPlaylist.mockResolvedValue(mockPlaylistWithTracks)

      await store.loadPlaylistTracks('pl1')

      expect(mockApiService.getPlaylist).toHaveBeenCalledWith('pl1')
      expect(store.getTracksForPlaylist('pl1')).toHaveLength(2)
    })

    it('should handle track loading errors', async () => {
      const error = new Error('Failed to load tracks')
      mockApiService.getPlaylistTracks.mockRejectedValue(error)

      await store.loadPlaylistTracks('pl1')

      expect(store.error).toBe('Failed to load tracks')
    })

    it('should get tracks for playlist', async () => {
      const mockTracks = [
        { id: 't1', number: 1, title: 'Track 1', filename: 'track1.mp3' }
      ]

      mockApiService.getPlaylistTracks.mockResolvedValue(mockTracks)
      await store.loadPlaylistTracks('pl1')

      const tracks = store.getTracksForPlaylist('pl1')
      expect(tracks).toHaveLength(1)
      expect(tracks[0].title).toBe('Track 1')
    })

    it('should get track by number', async () => {
      const mockTracks = [
        { id: 't1', number: 1, title: 'Track 1', filename: 'track1.mp3' },
        { id: 't2', number: 2, title: 'Track 2', filename: 'track2.mp3' }
      ]

      mockApiService.getPlaylistTracks.mockResolvedValue(mockTracks)
      await store.loadPlaylistTracks('pl1')

      const track = store.getTrackByNumber('pl1', 2)
      expect(track?.title).toBe('Track 2')

      const nonExistent = store.getTrackByNumber('pl1', 99)
      expect(nonExistent).toBeUndefined()
    })

    it('should delete track', async () => {
      mockApiService.deleteTrack.mockResolvedValue({ success: true })

      await store.deleteTrack('pl1', [1, 2])

      expect(mockApiService.deleteTrack).toHaveBeenCalledWith('pl1', [1, 2])
    })

    it('should reorder tracks', async () => {
      mockApiService.reorderTracks.mockResolvedValue({ success: true })

      await store.reorderTracks('pl1', 1, 2)

      expect(mockApiService.reorderTracks).toHaveBeenCalledWith('pl1', 1, 2)
    })

    it('should move track between playlists', async () => {
      mockApiService.moveTrack.mockResolvedValue({ success: true })

      await store.moveTrackBetweenPlaylists('pl1', 'pl2', 1, 2)

      expect(mockApiService.moveTrack).toHaveBeenCalledWith('pl1', 'pl2', 1, 2)
    })

    it('should clear tracks for playlist', () => {
      // Set some tracks first using optimistic updates
      store.setTracksOptimistic('pl1', [
        { id: 't1', number: 1, title: 'Track 1', filename: 'track1.mp3' }
      ])

      expect(store.getTracksForPlaylist('pl1')).toHaveLength(1)

      store.clearPlaylistTracks('pl1')

      expect(store.getTracksForPlaylist('pl1')).toHaveLength(0)
    })
  })

  describe('Getters and Computed Properties', () => {
    beforeEach(async () => {
      const mockPlaylists = [
        { id: 'pl1', title: 'Playlist 1', description: 'First playlist', track_count: 1 },
        { id: 'pl2', title: 'Playlist 2', description: 'Second playlist', track_count: 0 }
      ]
      mockApiService.getPlaylists.mockResolvedValue(mockPlaylists)
      await store.loadAllPlaylists()

      const mockTracks = [
        { id: 't1', number: 1, title: 'Track 1', filename: 'track1.mp3' }
      ]
      mockApiService.getPlaylistTracks.mockResolvedValue(mockTracks)
      await store.loadPlaylistTracks('pl1')
    })

    it('should get all playlists', () => {
      const playlists = store.getAllPlaylists
      expect(playlists).toHaveLength(2)
      expect(playlists[0].title).toBe('Playlist 1')
    })

    it('should get playlist with tracks', () => {
      const playlistWithTracks = store.getPlaylistWithTracks('pl1')
      expect(playlistWithTracks?.title).toBe('Playlist 1')
      expect(playlistWithTracks?.tracks).toHaveLength(1)
    })

    it('should check if has playlist data', () => {
      expect(store.hasPlaylistData('pl1')).toBe(true)
      expect(store.hasPlaylistData('nonexistent')).toBe(false)
    })

    it('should check if has tracks data', () => {
      expect(store.hasTracksData('pl1')).toBe(true)
      expect(store.hasTracksData('pl2')).toBe(false)
    })

    it('should use optimized track lookup', async () => {
      const track = store.getTrackByNumberOptimized('pl1', 1)
      expect(track?.title).toBe('Track 1')

      const nonExistent = store.getTrackByNumberOptimized('pl1', 99)
      expect(nonExistent).toBe(null)
    })
  })

  describe('State Management', () => {
    it('should track loading state', async () => {
      expect(store.isLoading).toBe(false)

      const promise = store.loadAllPlaylists()
      expect(store.isLoading).toBe(true)

      await promise
      expect(store.isLoading).toBe(false)
    })

    it('should handle and clear errors', async () => {
      const error = new Error('Test error')
      mockApiService.getPlaylists.mockRejectedValue(error)

      await store.loadAllPlaylists()
      expect(store.error).toBe('Test error')

      // Error should be cleared on successful operation
      mockApiService.getPlaylists.mockResolvedValue([])
      await store.loadAllPlaylists()
      expect(store.error).toBe(null)
    })

    it('should track last sync time', async () => {
      const beforeSync = Date.now()
      mockApiService.getPlaylists.mockResolvedValue([])

      await store.loadAllPlaylists()

      expect(store.lastSync).toBeGreaterThanOrEqual(beforeSync)
      expect(store.lastSync).toBeLessThanOrEqual(Date.now())
    })

    it('should force sync when requested', async () => {
      mockApiService.getPlaylists.mockResolvedValue([])
      await store.loadAllPlaylists()

      const firstSync = store.lastSync

      // Force sync should reload even if recently synced
      await store.forceSync()

      expect(store.lastSync).toBeGreaterThan(firstSync)
    })
  })

  describe('Performance Optimizations', () => {
    it('should provide optimized track lookups', async () => {
      const mockTracks = Array.from({ length: 100 }, (_, i) => ({
        id: `t${i}`,
        number: i + 1,
        title: `Track ${i + 1}`,
        filename: `track${i + 1}.mp3`
      }))

      mockApiService.getPlaylistTracks.mockResolvedValue(mockTracks)
      await store.loadPlaylistTracks('pl1')

      const startTime = performance.now()
      const track = store.getTrackByNumberOptimized('pl1', 50)
      const endTime = performance.now()

      expect(track?.title).toBe('Track 50')
      expect(endTime - startTime).toBeLessThan(1) // Should be very fast O(1) lookup
    })

    it('should handle optimistic updates', () => {
      const tracks = [
        { id: 't1', number: 1, title: 'Track 1', filename: 'track1.mp3' }
      ]

      store.setTracksOptimistic('pl1', tracks)

      expect(store.getTracksForPlaylist('pl1')).toHaveLength(1)
      expect(store.getTrackByNumber('pl1', 1)?.title).toBe('Track 1')
    })
  })

  describe('Cleanup', () => {
    it('should cleanup store state', () => {
      // Add some data first
      store.setTracksOptimistic('pl1', [
        { id: 't1', number: 1, title: 'Track 1', filename: 'track1.mp3' }
      ])

      expect(store.getAllPlaylists).toHaveLength(0) // No playlists added in this test
      expect(store.getTracksForPlaylist('pl1')).toHaveLength(1)

      store.cleanup()

      expect(store.getAllPlaylists).toHaveLength(0)
      expect(store.getTracksForPlaylist('pl1')).toHaveLength(0)
      expect(store.isInitialized).toBe(false)
    })
  })
})