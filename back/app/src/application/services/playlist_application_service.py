# Copyright (c) 2025 Jonathan Piette
# This file is part of TheOpenMusicBox and is licensed for non-commercial use only.
# See the LICENSE file for details.

"""
Playlist application service following Domain-Driven Design principles.

This service coordinates playlist operations between the domain layer
and external services, implementing use cases without containing business logic.
"""

from typing import Optional, Dict, Any
from app.src.monitoring import get_logger
from app.src.monitoring.logging.log_level import LogLevel
from app.src.services.error.unified_error_decorator import handle_service_errors
from app.src.domain.data.models.playlist import Playlist
from app.src.domain.data.models.track import Track

logger = get_logger(__name__)


class DataApplicationService:
    """Application service for playlist operations.

    Coordinates between domain layer and infrastructure to implement
    playlist use cases following DDD principles.
    """

    def __init__(self, playlist_repository, file_system_service=None):
        """Initialize playlist application service.

        Args:
            playlist_repository: Repository for playlist persistence (required)
            file_system_service: Service for file system operations
        """
        if playlist_repository is None:
            raise ValueError("Playlist repository is required for application service")
        self._playlist_repository = playlist_repository
        self._file_system_service = file_system_service

    async def create_playlist_use_case(self, name: str, description: str = None) -> Dict[str, Any]:
        """Use case: Create a new playlist.

        Args:
            name: Playlist name
            description: Optional description

        Returns:
            Result dictionary with playlist data
        """
        # Create domain entity with empty tracks list
        playlist = Playlist(name=name, tracks=[], description=description)
        # Validate using domain rules
        if not playlist.is_valid():
            return {
                "status": "error",
                "message": "Invalid playlist data",
                "error_type": "validation_error",
            }
        # Persist through repository
        playlist_data = {
            "title": name,
            "description": description,
            "path": None,  # Path will be generated by repository
        }
        try:
            playlist_id = await self._playlist_repository.create_playlist(playlist_data)
            logger.log(LogLevel.INFO, f"✅ Created playlist via application service: {name}")
            return {
                "status": "success",
                "message": "Playlist created successfully",
                "playlist_id": playlist_id,
                "playlist": {"id": playlist_id, "name": name, "description": description, "tracks": []},
            }
        except Exception as e:
            logger.log(LogLevel.ERROR, f"Failed to create playlist: {e}")
            return {
                "status": "error",
                "message": f"Failed to create playlist: {str(e)}",
                "error_type": "repository_error",
            }

    async def get_playlist_use_case(self, playlist_id: str) -> Dict[str, Any]:
        """Use case: Get a playlist by ID.

        Args:
            playlist_id: Playlist identifier

        Returns:
            Result dictionary with playlist data
        """
        try:
            # Get from repository
            playlist = await self._playlist_repository.get_playlist_by_id(playlist_id)
            if not playlist:
                return {
                    "status": "error",
                    "message": f"Playlist not found: {playlist_id}",
                    "error_type": "not_found",
                }
            return {
                "status": "success",
                "message": "Playlist retrieved successfully",
                "playlist": self._serialize_playlist(playlist),
            }
        except Exception as e:
            logger.log(LogLevel.ERROR, f"Failed to get playlist: {e}")
            return {
                "status": "error",
                "message": f"Failed to retrieve playlist: {str(e)}",
                "error_type": "internal_error",
            }

    async def delete_playlist_use_case(self, playlist_id: str) -> Dict[str, Any]:
        """Use case: Delete a playlist.

        Args:
            playlist_id: Playlist identifier to delete

        Returns:
            Result dictionary with operation status
        """
        # Check if playlist exists
        playlist = await self._playlist_repository.get_playlist_by_id(playlist_id)
        if not playlist:
            return {
                "status": "error",
                "message": f"Playlist not found: {playlist_id}",
                "error_type": "not_found",
            }

        # Delete from repository
        success = await self._playlist_repository.delete_playlist(playlist_id)
        if success:
            logger.log(LogLevel.INFO, f"✅ Deleted playlist via application service: {playlist_id}")
            return {
                "status": "success",
                "message": "Playlist deleted successfully",
                "playlist_id": playlist_id,
            }
        else:
            return {
                "status": "error",
                "message": "Failed to delete playlist",
                "error_type": "repository_error",
            }

    async def add_track_to_playlist_use_case(
        self, playlist_id: str, track_data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Use case: Add a track to a playlist.

        Args:
            playlist_id: Target playlist ID
            track_data: Track information

        Returns:
            Result dictionary
        """
        # Get playlist
        logger.log(LogLevel.INFO, f"🔍 Getting playlist for track addition: {playlist_id}")
        playlist_result = await self.get_playlist_use_case(playlist_id)
        logger.log(LogLevel.INFO, f"📋 Playlist result: status={playlist_result.get('status')}")
        if playlist_result["status"] != "success":
            logger.log(LogLevel.ERROR, f"❌ Failed to get playlist: {playlist_result}")
            return playlist_result
        # Create track domain entity
        logger.log(LogLevel.INFO, f"🎵 Creating track entity with data: {track_data}")
        track = Track(
            track_number=track_data.get("track_number", 1),
            title=track_data.get("title", "Unknown"),
            filename=track_data.get("filename", ""),
            file_path=track_data.get("file_path", ""),
            duration_ms=track_data.get("duration_ms"),
            artist=track_data.get("artist"),
            album=track_data.get("album"),
        )
        logger.log(
            LogLevel.INFO, f"✅ Track entity created: title={track.title}, valid={track.is_valid()}"
        )
        # Validate track using domain rules
        if not track.is_valid():
            logger.log(LogLevel.ERROR, f"❌ Track validation failed: {track}")
            return {
                "status": "error",
                "message": "Invalid track data",
                "error_type": "validation_error",
            }
        # Add track through repository
        logger.log(LogLevel.INFO, f"🔍 Getting playlist entity from repository: {playlist_id}")
        playlist_entity = await self._playlist_repository.get_playlist_by_id(playlist_id)
        if not playlist_entity:
            logger.log(LogLevel.ERROR, f"❌ Playlist entity not found in repository: {playlist_id}")
            return {
                "status": "error",
                "message": f"Playlist not found: {playlist_id}",
                "error_type": "not_found",
            }
        logger.log(
            LogLevel.INFO, f"✅ Playlist entity found: {playlist_entity.get('title', 'Unknown')}"
        )

        # Add track using repository method
        track_dict = {
            "track_number": track.track_number,
            "title": track.title,
            "filename": track.filename,
            "file_path": track.file_path,
            "duration": track.duration_ms,
            "artist": track.artist,
            "album": track.album,
        }
        logger.log(LogLevel.INFO, f"💾 Calling repository.add_track with: {track_dict}")
        success = await self._playlist_repository.add_track(playlist_id, track_dict)
        logger.log(LogLevel.INFO, f"📊 Repository add_track result: {success}")
        if success:
            logger.log(LogLevel.INFO, f"✅ Added track to playlist via application service")
            return {
                "status": "success",
                "message": "Track added successfully",
                "playlist_id": playlist_id,
                "track": self._serialize_track(track),
            }
        else:
            return {
                "status": "error",
                "message": "Failed to add track to playlist",
                "error_type": "repository_error",
            }

    async def sync_playlists_with_filesystem_use_case(
        self, upload_folder_path: str = None
    ) -> Dict[str, Any]:
        """Use case: Synchronize playlists with filesystem.

        Coordinates domain operations with file system service.

        Returns:
            Result dictionary with sync statistics
        """
        # Coordinate filesystem sync through file system service and repository
        if not self._file_system_service:
            return {
                "status": "error",
                "message": "File system service not available",
                "error_type": "service_unavailable",
            }
        # Use file system service to scan and sync
        if upload_folder_path:
            from pathlib import Path

            upload_path = Path(upload_folder_path)
            logger.log(LogLevel.INFO, f"🔄 Scanning upload folder: {upload_path}")
            # Use the file system service to scan directories
            stats = await self._file_system_service.sync_with_filesystem()
            logger.log(LogLevel.INFO, f"📊 Filesystem sync stats: {stats}")
        else:
            # Fallback stats if no path provided
            stats = {
                "processed_directories": 0,
                "created_playlists": 0,
                "updated_playlists": 0,
                "added_tracks": 0,
                "removed_tracks": 0,
            }
        logger.log(LogLevel.INFO, "✅ Filesystem sync completed via application service")
        return {"status": "success", "message": "Filesystem sync completed", "statistics": stats}

    async def get_all_playlists_use_case(
        self, page: int = 1, page_size: int = 50
    ) -> Dict[str, Any]:
        """Use case: Get all playlists with pagination.

        Args:
            page: Page number (1-based)
            page_size: Number of playlists per page

        Returns:
            Result dictionary with playlists data
        """
        # Get from repository
        limit = page_size
        offset = (page - 1) * page_size
        playlists = await self._playlist_repository.find_all(limit=limit, offset=offset)
        total_count = await self._playlist_repository.count()
        if not playlists:
            playlists = []
        serialized_playlists = [self._serialize_playlist(playlist) for playlist in playlists]
        logger.log(
            LogLevel.INFO, f"✅ Retrieved {len(playlists)} playlists via application service"
        )
        return {
            "status": "success",
            "message": "Playlists retrieved successfully",
            "playlists": serialized_playlists,
            "pagination": {
                "page": page,
                "page_size": page_size,
                "total_count": total_count,
                "total_pages": (total_count + page_size - 1) // page_size,
            },
        }

    async def start_playlist_by_id(self, playlist_id: str, audio_service=None) -> Dict[str, Any]:
        """CENTRALIZED: Start playing a playlist by ID (used by both UI and NFC flows).

        This is the single point of convergence for playlist starting logic.
        Both UI and NFC flows should use this method.

        Args:
            playlist_id: ID of the playlist to start
            audio_service: Audio service to use for playback (can be None)

        Returns:
            Dict[str, Any]: Result dictionary with keys:
                - success: bool indicating if operation succeeded
                - message: str description of result
                - error_type: str type of error if failed (not_found, empty_playlist, etc.)
                - details: Dict with additional information
        """
        return await self.start_playlist_with_details(playlist_id, audio_service)

    async def start_playlist_with_details(self, playlist_id: str, audio_service) -> Dict[str, Any]:
        """Use case: Start playing a playlist with detailed error handling.

        This method coordinates between the domain layer and infrastructure
        to load and start playing a playlist.

        Args:
            playlist_id: ID of the playlist to start
            audio_service: Audio service to use for playback (can be None)

        Returns:
            Dict[str, Any]: Result dictionary with keys:
                - success: bool indicating if operation succeeded
                - message: str description of result
                - error_type: str type of error if failed (not_found, empty_playlist, etc.)
                - details: Dict with additional information
        """
        # Get playlist from repository
        playlist_data = await self._playlist_repository.get_playlist_by_id(playlist_id)
        if not playlist_data:
            return {
                "success": False,
                "message": f"Playlist not found: {playlist_id}",
                "error_type": "not_found",
                "details": {"playlist_id": playlist_id},
            }
        # Check if playlist has tracks
        tracks = playlist_data.get("tracks", [])
        if not tracks:
            return {
                "success": False,
                "message": f"Playlist '{playlist_data.get('title', playlist_id)}' is empty",
                "error_type": "empty_playlist",
                "details": {
                    "playlist_id": playlist_id,
                    "playlist_name": playlist_data.get("title"),
                },
            }
        # Create tracks first, then playlist with tracks
        playlist_tracks = []
        track_count = 0
        valid_tracks = 0
        for track_data in tracks:
            # Skip None or invalid track data
            if not track_data or not isinstance(track_data, dict):
                logger.log(LogLevel.WARNING, f"Skipping invalid track data: {track_data}")
                continue

            # Validate that track has minimum required data
            if not track_data.get("id") and not track_data.get("filename"):
                logger.log(
                    LogLevel.WARNING, f"Skipping track with missing id and filename: {track_data}"
                )
                continue

            # Generate file_path if missing but filename exists
            file_path = track_data.get("file_path", "")
            filename = track_data.get("filename", "")
            if not file_path and filename:
                # For playlists without a path, use the exact folder name from file system
                # Prefer title (display name) over path (sanitized name) to match real folders
                playlist_folder = playlist_data.get("title") or playlist_data.get("path", "Unknown")
                # Use absolute path from config.upload_folder
                from app.src.config import config
                from pathlib import Path

                file_path = str(Path(config.upload_folder) / playlist_folder / filename)

            # Validate and sanitize duration
            duration_ms = track_data.get("duration_ms")
            if duration_ms is not None and duration_ms < 0:
                logger.log(
                    LogLevel.WARNING,
                    f"Track {track_data.get('id', 'unknown')} has negative "
                    f"duration {duration_ms}, setting to None",
                )
                duration_ms = None

            track = Track(
                track_number=track_data.get("track_number", 0),
                title=track_data.get("title", "Unknown"),
                filename=filename,
                file_path=file_path,
                duration_ms=duration_ms,
                artist=track_data.get("artist"),
                album=track_data.get("album"),
                id=track_data.get("id"),
            )
            playlist_tracks.append(track)
            track_count += 1
            if track.is_valid():
                valid_tracks += 1
        # Create domain playlist entity WITH tracks included
        playlist = Playlist(
            name=playlist_data.get("title", "Unknown"),
            tracks=playlist_tracks,  # Include tracks in constructor
            description=playlist_data.get("description"),
            id=playlist_id,
            nfc_tag_id=playlist_data.get("nfc_tag_id"),
        )
        if valid_tracks == 0:
            return {
                "success": False,
                "message": f"Playlist '{playlist.title}' has no valid tracks",
                "error_type": "missing_tracks",
                "details": {
                    "playlist_id": playlist_id,
                    "playlist_name": playlist.title,
                    "total_tracks": track_count,
                    "valid_tracks": valid_tracks,
                },
            }
        # Start playlist using either the provided audio service or create a unified audio player
        if audio_service and hasattr(audio_service, "set_playlist"):
            # Use the provided audio service
            success = audio_service.set_playlist(playlist)
            if not success:
                return {
                    "success": False,
                    "message": (
                        f"Failed to load playlist '{playlist.title}' " "into audio service"
                    ),
                    "error_type": "audio_failure",
                    "details": {
                        "playlist_id": playlist_id,
                        "playlist_name": playlist.title,
                        "track_count": track_count,
                    },
                }
        else:
            # Fallback: Create a unified audio player directly
            try:
                from app.src.domain.audio.backends.implementations.audio_factory import (
                    get_unified_audio_player,
                )

                unified_player = get_unified_audio_player()
                success = unified_player.set_playlist(playlist)
                if not success:
                    return {
                        "success": False,
                        "message": (
                            f"Failed to load playlist '{playlist.title}' " "into unified audio player"
                        ),
                        "error_type": "audio_failure",
                        "details": {
                            "playlist_id": playlist_id,
                            "playlist_name": playlist.title,
                            "track_count": track_count,
                        },
                    }
            except Exception as e:
                logger.log(LogLevel.ERROR, f"Failed to create unified audio player: {e}")
                return {
                    "success": False,
                    "message": f"Failed to initialize audio player: {str(e)}",
                    "error_type": "audio_initialization_failure",
                    "details": {
                        "playlist_id": playlist_id,
                        "playlist_name": playlist.title,
                        "track_count": track_count,
                        "error": str(e),
                    },
                }
        logger.log(
            LogLevel.INFO,
            f"✅ Playlist '{playlist.title}' started successfully via application service",
        )
        return {
            "success": True,
            "message": f"Playlist '{playlist.title}' started successfully",
            "details": {
                "playlist_id": playlist_id,
                "playlist_name": playlist.title,
                "track_count": track_count,
                "valid_tracks": valid_tracks,
                "first_track": tracks[0].get("title") if tracks else None,
            },
        }

    def _serialize_playlist(self, playlist) -> Dict[str, Any]:
        """Serialize playlist for API response.

        Args:
            playlist: Playlist entity or data

        Returns:
            Serialized playlist data
        """
        if isinstance(playlist, Playlist):
            return {
                "id": playlist.id,
                "name": playlist.name,
                "title": playlist.title,  # Legacy compatibility
                "description": playlist.description,
                "nfc_tag_id": playlist.nfc_tag_id,
                "path": playlist.path,
                "tracks": [self._serialize_track(track) for track in playlist.tracks],
                "track_count": len(playlist.tracks),
                "total_duration_ms": playlist.get_total_duration_ms(),
                "is_empty": playlist.is_empty(),
            }
        else:
            # Handle legacy format during transition
            return playlist

    async def get_playlist_id_by_nfc_tag(self, nfc_tag_id: str) -> Optional[str]:
        """Use case: Get playlist ID from NFC tag (for centralized flow).

        Args:
            nfc_tag_id: NFC tag identifier

        Returns:
            Playlist ID if found, None otherwise
        """
        # Get minimal data from repository - just the ID
        playlist = await self._playlist_repository.find_by_nfc_tag(nfc_tag_id)
        if not playlist:
            logger.log(LogLevel.INFO, f"🏷️ No playlist found for NFC tag: {nfc_tag_id}")
            return None
        playlist_id = playlist.get("id")
        logger.log(LogLevel.INFO, f"✅ Found playlist ID for NFC tag {nfc_tag_id}: {playlist_id}")
        return playlist_id

    async def get_playlist_by_nfc_tag(self, nfc_tag_id: str) -> Optional[Dict[str, Any]]:
        """Use case: Get a playlist by NFC tag ID.

        DEPRECATED: Use get_playlist_id_by_nfc_tag() + start_playlist_with_details() instead.

        Args:
            nfc_tag_id: NFC tag identifier

        Returns:
            Playlist data if found, None otherwise
        """
        # Get from repository
        playlist = await self._playlist_repository.get_playlist_by_nfc_tag(nfc_tag_id)
        if not playlist:
            logger.log(LogLevel.INFO, f"🏷️ No playlist found for NFC tag: {nfc_tag_id}")
            return None
        logger.log(
            LogLevel.INFO,
            f"✅ Found playlist for NFC tag {nfc_tag_id}: " f"{playlist.get('title', 'Unknown')}",
        )
        return self._serialize_playlist(playlist)

    async def associate_nfc_tag(self, playlist_id: str, nfc_tag_id: str) -> bool:
        """Use case: Associate an NFC tag with a playlist.

        Args:
            playlist_id: Playlist ID to associate
            nfc_tag_id: NFC tag ID to associate

        Returns:
            True if association succeeded, False otherwise
        """
        success = await self._playlist_repository.associate_nfc_tag(playlist_id, nfc_tag_id)
        if success:
            logger.log(
                LogLevel.INFO, f"✅ Associated NFC tag {nfc_tag_id} with playlist {playlist_id}"
            )
        else:
            logger.log(
                LogLevel.ERROR,
                f"❌ Failed to associate NFC tag {nfc_tag_id} with playlist {playlist_id}",
            )
        return success

    async def disassociate_nfc_tag(self, playlist_id: str) -> bool:
        """Use case: Disassociate an NFC tag from a playlist.

        Args:
            playlist_id: Playlist ID to disassociate

        Returns:
            True if disassociation succeeded, False otherwise
        """
        success = await self._playlist_repository.disassociate_nfc_tag(playlist_id)
        if success:
            logger.log(LogLevel.INFO, f"✅ Disassociated NFC tag from playlist {playlist_id}")
        else:
            logger.log(
                LogLevel.ERROR, f"❌ Failed to disassociate NFC tag from playlist {playlist_id}"
            )
        return success

    def _serialize_track(self, track) -> Dict[str, Any]:
        """Serialize track for API response.

        Args:
            track: Track entity

        Returns:
            Serialized track data
        """
        if isinstance(track, Track):
            return {
                "id": track.id,
                "track_number": track.track_number,
                "title": track.title,
                "filename": track.filename,
                "file_path": track.file_path,
                "duration_ms": track.duration_ms,
                "artist": track.artist,
                "album": track.album,
                "exists": track.exists,
                "display_name": track.get_display_name(),
            }
        else:
            # Handle legacy format during transition
            return track

    def _sanitize_folder_name(self, name: str) -> str:
        """Sanitize a name for use as a folder name.

        Args:
            name: Name to sanitize

        Returns:
            Sanitized folder name safe for filesystem use
        """
        import re

        # Remove or replace problematic characters
        sanitized = re.sub(r'[<>:"/\\|?*\[\]]', "", name)
        sanitized = re.sub(r"\s+", "_", sanitized.strip())

        # Limit length to avoid filesystem issues
        if len(sanitized) > 50:
            sanitized = sanitized[:50]

        # Ensure it's not empty
        if not sanitized:
            sanitized = "playlist"

        return sanitized


# Create singleton instance for dependency injection
from app.src.dependencies import get_playlist_repository_adapter
from app.src.services.filesystem_sync_service import FilesystemSyncService

# Create global instance with file system service
_filesystem_service = FilesystemSyncService()
playlist_app_service = DataApplicationService(get_playlist_repository_adapter(), _filesystem_service)
